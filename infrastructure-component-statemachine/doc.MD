## 1. æ¶æ„è®¾è®¡æ³¨æ„ç‚¹

### ğŸ”´ çŠ¶æ€æœºä¸ Temporal çš„èŒè´£åˆ†ç¦»

â€¢ çŠ¶æ€æœºï¼šè´Ÿè´£çŠ¶æ€è½¬æ¢é€»è¾‘éªŒè¯ã€æ¡ä»¶æ£€æŸ¥
â€¢ Temporalï¼šè´Ÿè´£æŒä¹…åŒ–ã€é‡è¯•ã€è¡¥å¿ã€é•¿æ—¶é—´æµç¨‹ç¼–æ’
â€¢ é¿å…ï¼šåœ¨çŠ¶æ€æœºä¸­ç›´æ¥è°ƒç”¨ Temporalï¼Œä¿æŒçŠ¶æ€æœºçš„çº¯å‡€æ€§

### ğŸ”´ å·¥ä½œæµç±»å‹è®¾è®¡

// å»ºè®®ä½¿ç”¨æšä¸¾åŒºåˆ†å·¥ä½œæµç±»å‹
enum WorkflowType {
AUTO_BACKGROUND, // åå°è‡ªåŠ¨æµç¨‹
EVENT_DRIVEN // äº‹ä»¶é©±åŠ¨æµç¨‹
}

// ç»Ÿä¸€çš„å·¥ä½œæµæ¥å£
@WorkflowInterface
public interface StateTransitionWorkflow {
@WorkflowMethod
void processTransition(WorkflowType type, StateTransitionRequest request);
}

## 2. åå°è‡ªåŠ¨å·¥ä½œæµæ³¨æ„ç‚¹

### ğŸ”´ å®šæ—¶è§¦å‘æœºåˆ¶

â€¢ ä½¿ç”¨ Temporal çš„ Workflow.sleep() è€Œéå¤–éƒ¨å®šæ—¶å™¨
â€¢ è€ƒè™‘ä½¿ç”¨ Cron Workflow å¤„ç†å®šæœŸæ£€æŸ¥
â€¢ é¿å…é•¿æ—¶é—´é˜»å¡ï¼Œåˆç†è®¾ç½®æ£€æŸ¥é—´éš”

### ğŸ”´ æ‰¹é‡å¤„ç†ç­–ç•¥

â€¢ é¿å…å•ä¸ª Workflow å¤„ç†è¿‡å¤šå®ä½“
â€¢ è€ƒè™‘åˆ†é¡µå¤„ç†å¤§é‡æ•°æ®
â€¢ å®ç°åˆç†çš„èƒŒå‹æ§åˆ¶æœºåˆ¶

### ğŸ”´ è‡ªåŠ¨æµç¨‹çš„å¯æ§æ€§

// æä¾›æ‰‹åŠ¨å¹²é¢„èƒ½åŠ›
@SignalMethod
void pauseAutoProcess();

@SignalMethod
void resumeAutoProcess();

@QueryMethod
boolean isAutoProcessPaused();

## 3. äº‹ä»¶é©±åŠ¨å·¥ä½œæµæ³¨æ„ç‚¹

### ğŸ”´ äº‹ä»¶å¹‚ç­‰æ€§

â€¢ åŒä¸€äº‹ä»¶å¤šæ¬¡è§¦å‘åº”äº§ç”Ÿç›¸åŒç»“æœ
â€¢ åœ¨ Activity å±‚é¢å®ç°å¹‚ç­‰æ€§æ£€æŸ¥
â€¢ è€ƒè™‘ä½¿ç”¨äº‹ä»¶å»é‡æœºåˆ¶

### ğŸ”´ äº‹ä»¶é¡ºåºæ€§

â€¢ å¯¹äºåŒä¸€å®ä½“ï¼Œç¡®ä¿äº‹ä»¶æŒ‰é¡ºåºå¤„ç†
â€¢ è€ƒè™‘ä½¿ç”¨ Temporal çš„ Session æˆ–å•çº¿ç¨‹ TaskQueue
â€¢ å®ç°äº‹ä»¶ç‰ˆæœ¬æ§åˆ¶

### ğŸ”´ å¼‚æ­¥äº‹ä»¶å¤„ç†

// é¿å…é˜»å¡äº‹ä»¶å‘é€æ–¹
@WorkflowMethod(name = "processEventAsync")
void processEventAsync(StateEvent event);

// æä¾›äº‹ä»¶å¤„ç†çŠ¶æ€æŸ¥è¯¢
@QueryMethod
EventProcessingStatus getEventStatus(String eventId);

## 4. æŒä¹…åŒ–è®¾è®¡æ³¨æ„ç‚¹

### ğŸ”´ çŠ¶æ€å­˜å‚¨ç­–ç•¥

â€¢ å½“å‰çŠ¶æ€ï¼šå­˜å‚¨åœ¨ä¸šåŠ¡è¡¨ä¸­ï¼Œä¾¿äºæŸ¥è¯¢
â€¢ çŠ¶æ€å†å²ï¼šå•ç‹¬çš„å®¡è®¡è¡¨ï¼Œæ”¯æŒå†å²è¿½è¸ª
â€¢ å·¥ä½œæµçŠ¶æ€ï¼šä¾èµ– Temporal çš„å†…ç½®æŒä¹…åŒ–

### ğŸ”´ æ•°æ®ä¸€è‡´æ€§

// é¿å…çŠ¶æ€æœºçŠ¶æ€ä¸æ•°æ®åº“çŠ¶æ€ä¸ä¸€è‡´
@ActivityMethod
@Transactional
void atomicStateUpdate(String entityId, StateTransition transition) {
// 1. éªŒè¯å½“å‰çŠ¶æ€
// 2. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
// 3. æ›´æ–°çŠ¶æ€
// 4. è®°å½•å†å²
}

### ğŸ”´ å¹¶å‘æ§åˆ¶

â€¢ ä½¿ç”¨ä¹è§‚é”æˆ–æ‚²è§‚é”é˜²æ­¢å¹¶å‘ä¿®æ”¹
â€¢ è€ƒè™‘å®ä½“çº§åˆ«çš„å·¥ä½œæµäº’æ–¥
â€¢ å®ç°åˆç†çš„é‡è¯•é€€é¿ç­–ç•¥

## 5. æ‰©å±•æ€§è€ƒè™‘

### ğŸ”´ çŠ¶æ€æœºé…ç½®åŒ–

// æ”¯æŒåŠ¨æ€çŠ¶æ€æœºé…ç½®
interface StateMachineConfigProvider {
StateMachineConfig getConfig(String machineId, String version);
void updateConfig(String machineId, StateMachineConfig config);
}

// ç‰ˆæœ¬åŒ–çŠ¶æ€æœº
class VersionedStateMachine {
String version;
StateMachine<?, ?, ?> stateMachine;
Date effectiveDate;
}

### ğŸ”´ å¤šç§Ÿæˆ·æ”¯æŒ

â€¢ çŠ¶æ€æœºé…ç½®æŒ‰ç§Ÿæˆ·éš”ç¦»
â€¢ Temporal TaskQueue æŒ‰ç§Ÿæˆ·åˆ†ç¦»
â€¢ æ•°æ®å­˜å‚¨é€»è¾‘éš”ç¦»

### ğŸ”´ ç›‘æ§å’Œå¯è§‚æµ‹æ€§

// çŠ¶æ€è½¬æ¢æŒ‡æ ‡
@Component
public class StateTransitionMetrics {
@EventListener
void onStateTransition(StateTransitionEvent event) {
// è®°å½•è½¬æ¢è€—æ—¶ã€æˆåŠŸç‡ç­‰æŒ‡æ ‡
meterRegistry.counter("state.transition",
"from", event.getFrom(),
"to", event.getTo(),
"workflow_type", event.getWorkflowType()
).increment();
}
}

## 6. æ€§èƒ½ä¼˜åŒ–æ³¨æ„ç‚¹

### ğŸ”´ Activity ç²’åº¦æ§åˆ¶

â€¢ é¿å…è¿‡ç»†ç²’åº¦çš„ Activity è°ƒç”¨
â€¢ åˆå¹¶ç›¸å…³çš„æ•°æ®åº“æ“ä½œ
â€¢ å‡å°‘ç½‘ç»œè°ƒç”¨æ¬¡æ•°

### ğŸ”´ å·¥ä½œæµç”Ÿå‘½å‘¨æœŸç®¡ç†

// åŠæ—¶å®Œæˆå·¥ä½œæµï¼Œé¿å…é•¿æœŸè¿è¡Œ
@WorkflowImpl
public class StateTransitionWorkflowImpl {
@Override
public void processTransition(WorkflowType type, StateTransitionRequest request) {
try {
// å¤„ç†é€»è¾‘
} finally {
// ç¡®ä¿å·¥ä½œæµæ­£å¸¸ç»“æŸ
cleanupResources();
}
}
}

### ğŸ”´ ç¼“å­˜ç­–ç•¥

â€¢ çŠ¶æ€æœºå®ä¾‹ç¼“å­˜
â€¢ é…ç½®ä¿¡æ¯ç¼“å­˜
â€¢ é¿å…é‡å¤çš„æ•°æ®åº“æŸ¥è¯¢

## 7. é”™è¯¯å¤„ç†å’Œæ¢å¤

### ğŸ”´ åˆ†å±‚é”™è¯¯å¤„ç†

â€¢ çŠ¶æ€æœºå±‚ï¼šä¸šåŠ¡è§„åˆ™éªŒè¯é”™è¯¯
â€¢ Activity å±‚ï¼šæ•°æ®æ“ä½œé”™è¯¯
â€¢ Temporal å±‚ï¼šåŸºç¡€è®¾æ–½é”™è¯¯

### ğŸ”´ è¡¥å¿æœºåˆ¶è®¾è®¡

// ä¸ºæ¯ä¸ªå…³é”®æ“ä½œè®¾è®¡è¡¥å¿é€»è¾‘
@ActivityMethod
void compensateStateTransition(String entityId, StateTransition transition);

// æ”¯æŒæ‰‹åŠ¨è¡¥å¿è§¦å‘
@SignalMethod
void triggerManualCompensation(String compensationId);

## 8. æµ‹è¯•ç­–ç•¥

### ğŸ”´ åˆ†å±‚æµ‹è¯•

â€¢ å•å…ƒæµ‹è¯•ï¼šçŠ¶æ€æœºé€»è¾‘æµ‹è¯•
â€¢ é›†æˆæµ‹è¯•ï¼šTemporal + çŠ¶æ€æœºé›†æˆæµ‹è¯•
â€¢ ç«¯åˆ°ç«¯æµ‹è¯•ï¼šå®Œæ•´å·¥ä½œæµæµ‹è¯•

### ğŸ”´ æ—¶é—´æ§åˆ¶æµ‹è¯•

// ä½¿ç”¨ Temporal çš„æ—¶é—´æ§åˆ¶èƒ½åŠ›
@Test
void testTimeBasedTransition() {
testWorkflowRule.getTestTimeoutOptions()
.setTestTimeoutDuration(Duration.ofHours(1));
// æµ‹è¯•æ—¶é—´ç›¸å…³çš„çŠ¶æ€è½¬æ¢
}

è¿™äº›æ³¨æ„ç‚¹å°†å¸®åŠ©ä½ æ„å»ºä¸€ä¸ªå¥å£®ã€å¯æ‰©å±•çš„çŠ¶æ€æµè½¬ç³»ç»Ÿã€‚å»ºè®®ä¼˜å…ˆå®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œç„¶åé€æ­¥æ·»åŠ ç›‘æ§ã€ç¼“å­˜ç­‰å¢å¼ºç‰¹æ€§ã€‚
